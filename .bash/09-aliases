#!/usr/bin/env bash

# shellcheck disable=2139
true

# advice on using which, whence, and other shell built in functions
# https://unix.stackexchange.com/a/85250

# set default variables
  TTY_COLOR=""
  GNU_TTY_COLOR=""
  GNU_PRESERVE=""
  GNU=""

# create aliases to sudo and doas so that aliases can be run via sudo and doas
  if command -v sudo > /dev/null 2>&1; then
    alias sudo='sudo '
  fi
  if command -v doas > /dev/null 2>&1; then
    alias doas='doas '
  fi

# detect if tty color support is installed
  if command -v dircolors > /dev/null 2>&1; then
    TTY_COLOR="--color=tty"
    GNU_TTY_COLOR="--color=tty"
  fi

# detect if gnu coreutils are installed
  if command gdircolors > /dev/null 2>&1; then
    GNU_TTY_COLOR="--color=tty"
    GNU_PRESERVE="--preserve-root"
    GNU="g"
  fi

# directory management
  alias ..="cd .."
  alias cd..="cd .."

# set aliases which are dependent on the gnu version binaries
  if [ -z "${GNU}" ]; then
    # ls aliases
    alias ls="$(which ls)"' -F '"${GNU_TTY_COLOR}"
    alias lsa="$(which ls)"' -lah '"${GNU_TTY_COLOR}"
    alias l="$(which ls)"' -la '"${GNU_TTY_COLOR}"
    alias ll="$(which ls)"' -l '"${GNU_TTY_COLOR}"
    alias la="$(which ls)"' -lA --group-directories-first '"${GNU_TTY_COLOR}"
    alias ls.="$(which ls)"' -d .* '"${GNU_TTY_COLOR}"
    # add confrimation on mass changes
    alias mv="$(which mv)"' -i'
    alias cp="$(which cp)"' -i'
    # ln on openbsd doesn't have -i option, set only on linux systems
    if [[ $(uname) == 'Linux' ]]; then
      alias ln="$(which ln)"' -i'
    fi
    # prompt if changing perms or owner on more than 3 files at a time
    alias chown="$(which chown)"' '"${GNU_PRESERVE}"
    alias chmod="$(which chmod)"' '"${GNU_PRESERVE}"
    alias chgrp="$(which chgrp)"' '"${GNU_PRESERVE}"
  else
    # ls aliases
    alias ls="$(which gls)"' -F '"${GNU_TTY_COLOR}"
    alias lsa="$(which gls)"' -lah '"${GNU_TTY_COLOR}"
    alias l="$(which gls)"' -la '"${GNU_TTY_COLOR}"
    alias ll="$(which gls)"' -l '"${GNU_TTY_COLOR}"
    alias la="$(which gls)"' -lA --group-directories-first '"${GNU_TTY_COLOR}"
    alias ls.="$(which gls)"' -d .* '"${GNU_TTY_COLOR}"
    # promt on mass file changes
    alias mv="$(which gmv)"' -i'
    alias cp="$(which gcp)"' -i'
    alias ln="$(which gln)"' -i'
    # prompt if changing perms or owner on more than 3 files at a time
    alias chown="$(which gchown)"' '"${GNU_PRESERVE}"
    alias chmod="$(which gchmod)"' '"${GNU_PRESERVE}"
    alias chgrp="$(which gchgrp)"' '"${GNU_PRESERVE}"
  fi

# grep options
  # detect if gnu grep is installed, otherwise alias regular names
  if command -v ggrep > /dev/null 2>&1; then
    alias grep="$(which ggrep)"' --color=tty'
    alias fgrep="$(which gfgrep)"' --color=tty'
    alias egrep="$(which gegrep)"' --color=tty'
  elif [[ $(uname) == 'Linux' ]]; then
    alias grep="$(which grep)"' '"${TTY_COLOR}"
    alias fgrep="$(which fgrep)"' '"${TTY_COLOR}"
    alias egrep="$(which egrep)"' '"${TTY_COLOR}"
  fi

# ssh
  # alias ssh to change the term to xterm before the session starts
  alias ssh='TERM=xterm ssh'

# who
  # show user idle time
  alias who='who -u'

# htop
  if command -v htop > /dev/null 2>&1; then
    alias top="$(which htop)"
  fi

# diff
  if command -v colordiff > /dev/null 2>&1; then
    alias diff="$(which colordiff)"
  fi

# wget
  # enable continue of downloads
  if command -v wget > /dev/null 2>&1; then
    alias wget="$(which wget)"' -c'
  fi

# tar
  if command -v tar > /dev/null 2>&1; then
    alias untar="$(which tar)"' -zxvf'
  fi

# most
  if command -v most > /dev/null 2>&1; then
    PAGER="$(which most)"
    export PAGER
  fi

# rsync
  if command -v rsync > /dev/null 2>&1; then
    alias rsync-copy="$(which rsync)"' -avzh --progress --stats'
    alias rsync-mirror="$(which rsync)"' -avzh --progress --stats --delete-before --delete-excluded'
    alias rsync-move="$(which rsync)"' -avzh --progress --stats --remove-source-files'
    alias rsync-synchronize="$(which rsync)"' -avzuh --progress --stats --delete'
    alias rsync-update="$(which rsync)"' -avzuh --progress --stats'
  fi

# cli to online paste aliases
  alias termbin='nc termbin.com 9999'
  alias clibin='curl -q -F "clbin=<-" https://clbin.com; echo Append "?hl" to the url for highlighting'
  alias pastebin=clibin

# grep output for lines without common comment
  alias nocomments='grep -Evi '\''^( *)(#|$|;|//|--|rem|::|\"|\|\|)'\'''
  alias comments='grep -Ei '\''^(#|;|//|--|rem|::|\"|\|\|)'\'''

# dmesg
  if [[ $(uname) == 'Linux' ]]; then
    alias dmesg='dmesg -L auto -T'
  fi

# disk, partition, folder and file usage commands
  # disk usage in the current directory
  alias usagedirectory="$(which du)"' -ch 2> /dev/null | tail -1'

  # total disk usage
  alias usagedisk="$(which df)"' -hl --total | tail -1'

  # individual partition usages without the temporary memory values
  alias usagepartition="$(which df)"' -hlT --exclude-type=tmpfs --exclude-type=devtmpfs'

  # largest folders within current dir
  function usagehogs {
    du -k ./* 2>/dev/null | sort -nr | awk '{ if($1>=1024*1024) {size=$1/1024/1024; unit="G"} else if($1>=1024) {size=$1/1024; unit="M"} else {size=$1; unit="K"}; if(size<10) format="%.1f%s"; else format="%.0f%s"; res=sprintf(format,size,unit); printf "%-8s %s\n",res,$2 }'
  }

# monitoring function which tracks a file or folder for size changes over a period of time.
  function monitor_size() {
    # create "sub" functions which are used, and created, only by monitor_size when called

    # get the current size of the item to be monitored in a byte format for comparison
    function _get_size() {
      # check if the item to be monitored is a file
      if [[ -f "${1}" ]]
      then
        # get the current size of the file in bytes
        # shellcheck disable=2012
        ls -l "${1}" | awk '{ print $5 }'
      # check if the item to be monitored is a folder
      elif [[ -d "${1}" ]]
      then
        # get the current size of the folder in kilobytes
        du -s "${1}/" 2>/dev/null | awk '{ print $1 }'
      fi
    }

    # get the current size of the item to be monitored in human readable format
    function _get_size_human() {
      # check if the item to be monitored is a file
      if [[ -f "${1}" ]]
      then
        # get the current size of the file in human readable format
        # shellcheck disable=2012
        ls -lh "${1}" | awk '{ print $5 }'
      # check if the item to be monitored is a folder
      elif [[ -d "${1}" ]]
      then
        # get the current size of the folder in human readable format
        du -sh "${1}/" 2>/dev/null | awk '{ print $1 }'
      fi
    }

    # find if the item to be monitored is a file or folder
    function _get_path_type() {
      # check if the item to be monitored is a file
      if [[ -f "${1}" ]]
      then
        echo "file"
      # check if the item to be monitored is a folder
      elif [[ -d "${1}" ]]
      then
        echo "folder"
      else
        echo "error"
      fi
    }

    # verify that at least one parameter was passed to the function
    if [[ "${#}" == "0" ]]
    then
      # usage message if 0 parameters were passed
      echo "Usage: monitor_size [[file/folder path]] [[sleep_duration]]"
      echo "Monitors a file or folder for change in size over time."
      echo ""
      echo "  The path is the file or folder to monitor for change."
      echo "  Optional: The sleep duration is seconds between checking for change, default is 300 seconds."
    # check if the path type function returns an error for some reason; possibly a bad path
    elif [[ $(_get_path_type "${1}") == "error" ]]
    then
      echo "file/folder not found..."
    else
      # use bash parameter expansion to take second parameter, if passed, and save it to __watch_sleep, otherwise default to 300 seconds
      local __watch_sleep=${2:-300}

      # init the size variables so we can compare them later on
      local __watch_last_size=0
      local __watch_new_size=0

      # get current file/folder size
      __watch_new_size=$(_get_size "${1}")

      # output what is going to be checked and how often
      echo "Checking $(_get_path_type "${1}") for change every ${__watch_sleep} seconds..."
      echo ""
      echo "Time       Size"

      # enter a while loop until the last and new size are the same
      while [[ "${__watch_last_size}" != "${__watch_new_size}" ]]
      do
        __watch_last_size=${__watch_new_size}
        # output formatted message with date, time, and file size in human readable format
        echo "$(date +"%R:%S")   $(_get_size_human "${1}")"
        sleep "${__watch_sleep}"
        # get file size after the sleep
        __watch_new_size=$(_get_size "${1}")
      done

      # the size must have not changed during the last interval so we will output the last message
      echo ""
      echo "$(_get_path_type "${1}") has remained the same size for the last ${__watch_sleep} seconds..."
    fi

    # remove "sub" functions from the environment
    unset -f _get_size
    unset -f _get_size_human
    unset -f _get_path_type
  }

# unset variables
  unset TTY_COLOR
  unset GNU_TTY_COLOR
  unset GNU_PRESERVE
  unset GNU
